#!/usr/bin/env python 
# -*- coding: utf-8 -*-

class physical_system(object):
  """
  An instance of this class contains details of the physical system
  being evolved.
  """
  def __init__(self, domain, boundary_conditions, initial_conditions, advection_term, source_or_sink):
    """
    domain: Object/Input parameter file, that contains the details of the resolutions of the
            variables in which the advections are to be performed.

    boundary_conditions: Object/File which holds details of the B.C's(Dirichlet/Neumann/Periodic). 
                         In case of Dirichlet/Neumann boundary conditions, the values/derivative
                         values at the boundaries also need to be specified

    initial_conditions: Function which takes in the arrays as generated by domain, and assigns an
                        initial value to the distribution function being evolved. It is also ensured
                        that the I.C's are consistent with the B.C's

    advection_terms: Object whose attributes advection_term.A_p1, A_p2... are functions which are 
                     declared depending upon the system that is being evolved.

    source_or_sink: Function which provides us the expression that is used on the RHS of the advection 
                    equation.

    """
    # Getting resolution and size of configuration and velocity space:
    self.N_q1, self.q1_start, self.q1_end = domain.N_q1, domain.q1_end, domain.q1_end
    self.N_q2, self.q2_start, self.q2_end = domain.N_q2, domain.q2_end, domain.q2_end
    self.N_p1, self.p1_start, self.p1_end = domain.N_p1, domain.p1_end, domain.p1_end
    self.N_p2, self.p2_start, self.p2_end = domain.N_p2, domain.p2_end, domain.p2_end
    self.N_p3, self.p3_start, self.p3_end = domain.N_p3, domain.p3_end, domain.p3_end

    # Evaluating step size:
    self.dq1 = (self.q1_start - self.q1_end)/self.N_q1
    self.dq2 = (self.q2_start - self.q2_end)/self.N_q2
    self.dp1 = (self.p1_start - self.p1_end)/self.N_p1
    self.dp2 = (self.p2_start - self.p2_end)/self.N_p2
    self.dp3 = (self.p3_start - self.p3_end)/self.N_p3

    # Getting number of ghost zones, and the boundary conditions that are utilized
    self.N_ghost               = domain.N_ghost
    self.bc_in_x, self.bc_in_y = boundary_conditions.in_x, boundary_conditions.in_y

    # Placeholder for all the functions:
    # These will later be called in the linear_solver and nonlinear_solver:
    self.init = initial_conditions
    self.A_q1 = advection_term.A_q1
    self.A_q2 = advection_term.A_q2
    self.A_p1 = advection_term.A_p1
    self.A_p2 = advection_term.A_p2
    self.A_p3 = advection_term.A_p3
    
    self.source_or_sink = source_or_sink