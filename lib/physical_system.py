#!/usr/bin/env python 

from petsc4py import PETSc

import numpy as np
import arrayfire as af
import h5py

class physical_system(object):
  """
  An instance of this class contains details of the physical system
  being evolved.
  """
  def __init__(self, domain, boundary_conditions, initial_conditions, advection_term):
    """
    domain: Object/Input parameter file, that contains the details of the resolutions of the
            variables in which the advections are to be performed.

    boundary_conditions: Object/File which holds details of the B.C's(Dirichlet/Neumann/Periodic). 
                         In case of Dirichlet/Neumann boundary conditions, the values/derivative
                         values at the boundaries also need to be specified

    initial_conditions: Function which takes in the arrays as generated by domain, and assigns an
                        initial value to the distribution function being evolved. It is also ensured
                        that the I.C's are consistent with the B.C's

    advection_terms: Object whose attributes advection_term.T1, T2... are functions which are 
                     declared depending upon the system that is being evolved.
    """
    self.N_q1, self.q1_start, self.q1_end = domain.N_q1, domain.q1_end, domain.q1_end
    self.N_q2, self.q2_start, self.q2_end = domain.N_q2, domain.q2_end, domain.q2_end
    self.N_q3, self.q3_start, self.q3_end = domain.N_q3, domain.q3_end, domain.q3_end
    self.N_q4, self.q4_start, self.q4_end = domain.N_q4, domain.q4_end, domain.q4_end
    self.N_q5, self.q5_start, self.q5_end = domain.N_q5, domain.q5_end, domain.q5_end

    self.dq1 = (self.q1_start - self.q1_end)/self.N_q1
    self.dq2 = (self.q2_start - self.q2_end)/self.N_q2
    self.dq3 = (self.q3_start - self.q3_end)/self.N_q3
    self.dq4 = (self.q4_start - self.q4_end)/self.N_q4
    self.dq5 = (self.q5_start - self.q5_end)/self.N_q5

    self.N_ghost               = domain.N_ghost
    self.bc_in_x, self.bc_in_y = boundary_conditions.in_x, boundary_conditions.in_y

    ## Remaining boundary conditions of values at boundaries to be assigned here.
    
    self.comm = PETSc.COMM_WORLD.tompi4py()

    self.da = PETSc.DMDA().create([self.N_q1, self.N_q2],\
                                  dof = (self.N_q3 * self.N_q4 * self.N_q5),\
                                  stencil_width = self.N_ghost,\
                                  boundary_type = (self.bc_in_x, self.bc_in_y),\
                                  proc_sizes = (PETSc.DECIDE, PETSc.DECIDE), \
                                  stencil_type = 1, \
                                  comm = self.comm
                                 )

    self.q1_center = self.calculate_q1_center()
    self.q2_center = self.calculate_q2_center()
    self.q3_center = self.calculate_q3_center()
    self.q4_center = self.calculate_q4_center()
    self.q5_center = self.calculate_q5_center()

    self.f = initial_conditions(self, *args, **kwargs)

    self.T1 = advection_term.T1(self, *args, **kwargs)
    self.T2 = advection_term.T2(self, *args, **kwargs)
    self.T3 = advection_term.T3(self, *args, **kwargs)
    self.T4 = advection_term.T4(self, *args, **kwargs)
    self.T5 = advection_term.T5(self, *args, **kwargs)

  def calculate_q1_center(self):
    ((i_q1_lowest, i_q2_lowest), (N_q1_local, N_q2_local)) = self.da.getCorners()
    i_center = i_q1_lowest + 0.5
    i        = i_center + np.arange(-self.N_ghost, N_q1_local + self.N_ghost, 1)
    
    q1_center = self.q1_start  + i * self.dq1
    q1_center = af.Array.as_type(af.to_array(q1_center), af.Dtype.f64)

    # Tiling such that variation in q1 is along axis 0:
    q1_center = af.tile(q1_center, 1, N_q2_local + 2*self.N_ghost,\
                        self.N_q3 * self.N_q4 * self.N_q5, 1
                       )

    af.eval(q1_center)
    # Returns in positionsExpanded form(Nq1, Nq2, Nq3*Nq4*Nq5, 1)
    return(q1_center)

  def calculate_q2_center(self):
    ((i_q1_lowest, i_q2_lowest), (N_q1_local, N_q2_local)) = self.da.getCorners()
    i_center = i_q2_lowest + 0.5
    i        = i_center + np.arange(-self.N_ghost, N_q2_local + self.N_ghost, 1)
    
    q2_center = self.q2_start  + i * self.dq2
    q2_center = af.Array.as_type(af.to_array(q2_center), af.Dtype.f64)

    # Tiling such that variation in q2 is along axis 1:
    q2_center = af.tile(af.reorder(q2_center), N_q1_local + 2*self.N_ghost, 1,\
                        self.N_q3 * self.N_q4 * self.N_q5, 1
                       )

    af.eval(q2_center)
    # Returns in positionsExpanded form(Nq1, Nq2, Nq3*Nq4*Nq5, 1)
    return(q2_center)

  def calculate_q3_center(self):
    ((i_q1_lowest, i_q2_lowest), (N_q1_local, N_q2_local)) = self.da.getCorners()

    q3_center = self.q3_start  + (0.5 + np.arange(0, self.N_q3, 1)) * self.dq3
    q3_center = af.Array.as_type(af.to_array(q3_center), af.Dtype.f64)

    # Tiling such that variation in q3 is along axis 1:
    q3_center = af.tile(af.reorder(q3_center), (N_q1_local + 2*self.N_ghost)*(N_q2_local + 2*self.N_ghost),\
                        1, self.N_q4, self.N_q5
                       )

    af.eval(q3_center)
    # Returns in velocitiesExpanded form(Nq1*Nq2, Nq3, Nq4, Nq5)
    return(q3_center)

  def calculate_q4_center(self):
    ((i_q1_lowest, i_q2_lowest), (N_q1_local, N_q2_local)) = self.da.getCorners()

    q4_center = self.q4_start  + (0.5 + np.arange(0, self.N_q4, 1)) * self.dq4
    q4_center = af.Array.as_type(af.to_array(q4_center), af.Dtype.f64)

    # Tiling such that variation in q4 is along axis 2:
    q4_center = af.tile(af.reorder(q4_center, 2, 3, 0, 1),\
                        (N_q1_local + 2*self.N_ghost)*(N_q2_local + 2*self.N_ghost),\
                        self.N_q3, 1, self.N_q5
                       )

    af.eval(q4_center)
    # Returns in velocitiesExpanded form(Nq1*Nq2, Nq3, Nq4, Nq5)
    return(q4_center)

  def calculate_q5_center(self):
    ((i_q1_lowest, i_q2_lowest), (N_q1_local, N_q2_local)) = self.da.getCorners()

    q5_center = self.q5_start  + (0.5 + np.arange(0, self.N_q5, 1)) * self.dq5
    q5_center = af.Array.as_type(af.to_array(q5_center), af.Dtype.f64)

    # Tiling such that variation in q4 is along axis 2:
    q5_center = af.tile(af.reorder(q5_center, 1, 2, 3, 0),\
                        (N_q1_local + 2*self.N_ghost)*(N_q2_local + 2*self.N_ghost),\
                        self.N_q3, self.N_q4, 1
                       )

    af.eval(q5_center)
    # Returns in velocitiesExpanded form(Nq1*Nq2, Nq3, Nq4, Nq5)
    return(q5_center)

  def dump(self, file_name, **args):
    h5f = h5py.File(file_name, 'w')
    for variable_name in args:
      h5f.create_dataset(str(variable_name), data = variable_name)
    h5f.close()

  def compute_moments(self, moment):
    # how to make this work for arbitrary variables
    return