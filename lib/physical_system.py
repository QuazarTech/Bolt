#!/usr/bin/env python 

from petsc4py import PETSc

import numpy as np
import arrayfire as af
import h5py

class physical_system(object):
  """
  An instance of this class contains details of the physical system
  being evolved.
  """
  def __init__(self, domain, boundary_conditions, initial_conditions, advection_term, rhs):
    """
    domain: Object/Input parameter file, that contains the details of the resolutions of the
            variables in which the advections are to be performed.

    boundary_conditions: Object/File which holds details of the B.C's(Dirichlet/Neumann/Periodic). 
                         In case of Dirichlet/Neumann boundary conditions, the values/derivative
                         values at the boundaries also need to be specified

    initial_conditions: Function which takes in the arrays as generated by domain, and assigns an
                        initial value to the distribution function being evolved. It is also ensured
                        that the I.C's are consistent with the B.C's

    advection_terms: Object whose attributes advection_term.A_p1, A_p2... are functions which are 
                     declared depending upon the system that is being evolved.
    """
    self.N_q1, self.q1_start, self.q1_end = domain.N_q1, domain.q1_end, domain.q1_end
    self.N_q2, self.q2_start, self.q2_end = domain.N_q2, domain.q2_end, domain.q2_end
    self.N_p1, self.p1_start, self.p1_end = domain.N_p1, domain.p1_end, domain.p1_end
    self.N_p2, self.p2_start, self.p2_end = domain.N_p2, domain.p2_end, domain.p2_end
    self.N_p3, self.p3_start, self.p3_end = domain.N_p3, domain.p3_end, domain.p3_end

    self.dq1 = (self.q1_start - self.q1_end)/self.N_q1
    self.dq2 = (self.q2_start - self.q2_end)/self.N_q2
    self.dp1 = (self.p1_start - self.p1_end)/self.N_p1
    self.dp2 = (self.p2_start - self.p2_end)/self.N_p2
    self.dp3 = (self.p3_start - self.p3_end)/self.N_p3

    self.N_ghost               = domain.N_ghost
    self.bc_in_x, self.bc_in_y = boundary_conditions.in_x, boundary_conditions.in_y

    # Declaring the communicator:
    self._comm = PETSc.COMM_WORLD.tompi4py()

    # The DA structure is used in domain decomposition:
    # The following DA is used in the communication routines where information 
    # about the data of the distribution function needs to be communicated 
    # amongst processes. Additionally this structure automatically
    # takes care of applying periodic boundary conditions.
    self._da = PETSc.DMDA().create([self.N_q1, self.N_q2],\
                                   dof = (self.N_p1 * self.N_p2 * self.N_p3),\
                                   stencil_width = self.N_ghost,\
                                   boundary_type = (self.bc_in_x, self.bc_in_y),\
                                   proc_sizes = (PETSc.DECIDE, PETSc.DECIDE), \
                                   stencil_type = 1, \
                                   comm = self._comm
                                  )

    # Obtaining the array values of the cannonical variables: 
    self.q1_center = self._calculate_q1_center()
    self.q2_center = self._calculate_q2_center()
    self.p1_center = self._calculate_p1_center()
    self.p2_center = self._calculate_p2_center()
    self.p3_center = self._calculate_p3_center()

    self.f    = initial_conditions(self, *args, **kwargs)
    self.A_q1 = advection_term.A_q1(self, *args, **kwargs)
    self.A_q2 = advection_term.A_q2(self, *args, **kwargs)
    self.A_p1 = advection_term.A_p1(self, *args, **kwargs)
    self.A_p2 = advection_term.A_p2(self, *args, **kwargs)
    self.A_p3 = advection_term.A_p3(self, *args, **kwargs)
    self.g    = rhs(self, *args, **kwargs)

  def _calculate_q1_center(self):
    # Obtaining the left-bottom corner coordinates
    # (lowest values of the canonical coordinates in the local zone)
    # Additionally, we also obtain the size of the local zone
    ((i_q1_lowest, i_q2_lowest), (N_q1_local, N_q2_local)) = self.da.getCorners()

    i_center = i_q1_lowest + 0.5
    i        = i_center + np.arange(-self.N_ghost, N_q1_local + self.N_ghost, 1)
    
    q1_center = self.q1_start  + i * self.dq1
    q1_center = af.Array.as_type(af.to_array(q1_center), af.Dtype.f64)

    # Tiling such that variation in q1 is along axis 0:
    q1_center = af.tile(q1_center, 1, N_q2_local + 2*self.N_ghost,\
                        self.N_p1 * self.N_p2 * self.N_p3, 1
                       )

    af.eval(q1_center)
    # Returns in positionsExpanded form(Nq1, Nq2, Np1*Np2*Np3, 1)
    return(q1_center)

  def _calculate_q2_center(self):
    # Obtaining the left-bottom corner coordinates
    # (lowest values of the canonical coordinates in the local zone)
    # Additionally, we also obtain the size of the local zone
    ((i_q1_lowest, i_q2_lowest), (N_q1_local, N_q2_local)) = self.da.getCorners()

    i_center = i_q2_lowest + 0.5
    i        = i_center + np.arange(-self.N_ghost, N_q2_local + self.N_ghost, 1)
    
    q2_center = self.q2_start  + i * self.dq2
    q2_center = af.Array.as_type(af.to_array(q2_center), af.Dtype.f64)

    # Tiling such that variation in q2 is along axis 1:
    q2_center = af.tile(af.reorder(q2_center), N_q1_local + 2*self.N_ghost, 1,\
                        self.N_p1 * self.N_p2 * self.N_p3, 1
                       )

    af.eval(q2_center)
    # Returns in positionsExpanded form(Nq1, Nq2, Np1*Np2*Np3, 1)
    return(q2_center)

  def _calculate_p1_center(self):
    # Obtaining the left-bottom corner coordinates
    # (lowest values of the canonical coordinates in the local zone)
    # Additionally, we also obtain the size of the local zone
    ((i_q1_lowest, i_q2_lowest), (N_q1_local, N_q2_local)) = self.da.getCorners()

    p1_center = self.p1_start  + (0.5 + np.arange(0, self.N_p1, 1)) * self.dp1
    p1_center = af.Array.as_type(af.to_array(p1_center), af.Dtype.f64)

    # Tiling such that variation in p1 is along axis 1:
    p1_center = af.tile(af.reorder(p1_center), (N_q1_local + 2*self.N_ghost)*(N_q2_local + 2*self.N_ghost),\
                        1, self.N_p2, self.N_p3
                       )

    p1_center = af.moddims(p1_center,                   
                           (N_q1_local + 2 * self.N_ghost),\
                           (N_q2_local + 2 * self.N_ghost),\
                           self.N_p1*\
                           self.N_p2*\
                           self.N_p3,\
                           1
                          )

    af.eval(p1_center)
    # Returns in positionsExpanded form(Nq1, Nq2, Np1*Np2*Np3, 1)
    return(p1_center)

  def _calculate_p2_center(self):
    # Obtaining the left-bottom corner coordinates
    # (lowest values of the canonical coordinates in the local zone)
    # Additionally, we also obtain the size of the local zone
    ((i_q1_lowest, i_q2_lowest), (N_q1_local, N_q2_local)) = self.da.getCorners()

    p2_center = self.p2_start  + (0.5 + np.arange(0, self.N_p2, 1)) * self.dp2
    p2_center = af.Array.as_type(af.to_array(p2_center), af.Dtype.f64)

    # Tiling such that variation in p2 is along axis 2:
    p2_center = af.tile(af.reorder(p2_center, 2, 3, 0, 1),\
                        (N_q1_local + 2*self.N_ghost)*(N_q2_local + 2*self.N_ghost),\
                        self.N_p1, 1, self.N_p3
                       )

    p2_center = af.moddims(p2_center,                   
                           (N_q1_local + 2 * self.N_ghost),\
                           (N_q2_local + 2 * self.N_ghost),\
                           self.N_p1*\
                           self.N_p2*\
                           self.N_p3,\
                           1
                          )

    af.eval(p2_center)
    # Returns in positionsExpanded form(Nq1, Nq2, Np1*Np2*Np3, 1)
    return(p2_center)

  def _calculate_p3_center(self):
    # Obtaining the left-bottom corner coordinates
    # (lowest values of the canonical coordinates in the local zone)
    # Additionally, we also obtain the size of the local zone
    ((i_q1_lowest, i_q2_lowest), (N_q1_local, N_q2_local)) = self.da.getCorners()

    p3_center = self.p3_start  + (0.5 + np.arange(0, self.N_p3, 1)) * self.dp3
    p3_center = af.Array.as_type(af.to_array(p3_center), af.Dtype.f64)

    # Tiling such that variation in p3 is along axis 3:
    p3_center = af.tile(af.reorder(p3_center, 1, 2, 3, 0),\
                        (N_q1_local + 2*self.N_ghost)*(N_q2_local + 2*self.N_ghost),\
                        self.N_p1, self.N_p2, 1
                       )

    p3_center = af.moddims(p3_center,                   
                           (N_q1_local + 2 * self.N_ghost),\
                           (N_q2_local + 2 * self.N_ghost),\
                           self.N_p1*\
                           self.N_p2*\
                           self.N_p3,\
                           1
                          )
    af.eval(p3_center)
    # Returns in positionsExpanded form(Nq1, Nq2, Np1*Np2*Np3, 1)
    return(p3_center)

  def dump(self, file_name, **args):
    h5f = h5py.File(file_name + '.h5', 'w')
    for variable_name in args:
      h5f.create_dataset(str(variable_name), data = variable_name)
    h5f.close()

  def compute_moments(self, moment_variable):
    moment = af.sum(af.sum(af.sum(self.f * moment_variable, 3)*self.dp3, 2)*self.dp2, 1)*self.dp1
    
    af.eval(moment)
    return(moment)